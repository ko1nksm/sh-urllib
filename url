#!/bin/sh
# shellcheck disable=SC2059

##########################################################################
# url is released under the BSD Zero Clause License
# https://github.com/ko1nksm/sh-urllib
##########################################################################

set -eu

usage() {
  cat << 'HERE'
Usage: url [-r]              [-nSN] [--] URLPATH [PARAMETERS]...
Usage: url -p [-j DELIMITER] [-nSN] [--] FORMAT  [ARGUMENTS]...

  URLPATH: url path
  PARAMETERS: [ -KEY VALUE | =STRING | #FRAGMENT ]...

Global options:
  -n                      Do not print the trailing newline character
  -p, --printf            printf mode (default: build mode)

Build mode options:
  -r                      Remove empty value key

Printf mode options:
  -j, --join DELIMITER    Joins strings with the delimiter (default: '\n')

Character conversion Options:
  -S  Use + instead of %20
  -N  Normalize newline to \r\n
HERE
}

replace_all() {
  set -- "$1" "$2$3" "$3" "$4" ""
  while [ "$2" ]; do
    set -- "$1" "${2#*"$3"}" "$3" "$4" "$5${2%%"$3"*}$4"
  done
  eval "$1=\${5%\"\$4\"}"
}

do_urlbuild() {
  url=$(urlbuild "$@")
  printf '%s' "$url"
  [ "$SHURL_NONEWLINE" ] || echo
}

do_urlprintf() {
  format=$1 && shift
  urlprintf "${SHURL_DELIMITER}${format}" "$@" | {
    # shellcheck disable=SC2059
    delimiter=$(printf "${SHURL_DELIMITER}_")
    skip=$((${#delimiter} - 1))
    [ "$skip" -gt 0 ] && dd bs="$skip" count=1 >/dev/null 2>&1
    cat
  }
  [ "$SHURL_NONEWLINE" ] || echo
}

# urlbuild URLPATH [ARGUMENTS]...
#
#   URLPATH: url path
#   ARGUMENTS: [ -KEY VALUE | =STRING | #FRAGMENT ]...
#
#   Variables:
#     SHURL_SPACE: A character to use instead of %20
#     SHURL_EOL: Characters used on new lines
urlbuild() {
  LC_ALL=C awk -v space="$SHURL_SPACE" -v eol="$SHURL_EOL" \
    -v nullkey=$SHURL_REMOVENULLKEY \
  '
    function encode(map, str,   i, len, ret) {
      len = length(str); ret = ""
      for (i = 1; i <= len; i++) ret = ret map[substr(str, i, 1)]
      return ret
    }

    function fix_eol(eol,   i) {
      for (i = 1; i < ARGC; i++) gsub(/\r\n/, "\n", ARGV[i])
      for (i = 1; i < ARGC; i++) gsub(/\n/, eol, ARGV[i])
    }

    BEGIN {
      for(i = 0; i < 256; i++) {
        k = sprintf("%c", i); v = sprintf("%%%02X", i)
        uri[k] = (k ~ /[A-Za-z0-9_.!~*\47();\/?:@&=+$,#-]/) ? k : v
        url[k] = (k ~ /[A-Za-z0-9_.~-]/) ? k : v
      }
      if (length(space) > 0) uri[" "] = url[" "] = space
      if (length(eol) > 0) fix_eol(eol)

      path = encode(uri, ARGV[1]); params = fragment = ""
      for (i = 2; i < ARGC; i++) {
        if (sub(/^-/, "", ARGV[i])) {
          if (nullkey && ARGV[i + 1] == "") {
            i++
          } else {
            if (params) params = params "&"
            params = params encode(url, ARGV[i]) "=" encode(url, ARGV[++i])
          }
        } else if (sub(/^=/, "", ARGV[i])) {
          params = params encode(url, ARGV[i])
        } else if (sub(/^#/, "", ARGV[i])) {
          fragment = fragment "#" encode(url, ARGV[i])
        }
      }

      if (length(path) > 0 && length(params) > 0) path = path "?"
      print path params fragment
    }
  ' "$@"
}

# urlprintf FORMAT [ARGUMENTS]...
#
#   FORMAT: printf format
#   ARGUMENTS: printf argument to be URL-encoded
#
#   Variables:
#     SHURL_SPACE: A character to use instead of %20
#     SHURL_EOL: Characters used on new lines
urlprintf() {
  [ $# -le 1 ] && return 0
  {
    shift
    LC_ALL=C awk -v space="$SHURL_SPACE" -v eol="$SHURL_EOL" '
      function encode(map, str,   i, len, ret) {
        len = length(str); ret = ""
        for (i = 1; i <= len; i++) ret = ret map[substr(str, i, 1)]
        return ret
      }

      function fix_eol(eol,   i) {
        for (i = 1; i < ARGC; i++) gsub(/\r\n/, "\n", ARGV[i])
        for (i = 1; i < ARGC; i++) gsub(/\n/, eol, ARGV[i])
      }

      BEGIN {
        for(i = 0; i < 256; i++) {
          k = sprintf("%c", i); v = sprintf("%%%02X", i)
          url[k] = (k ~ /[A-Za-z0-9_.~-]/) ? k : v
        }
        if (length(space) > 0) uri[" "] = url[" "] = space
        if (length(eol) > 0) fix_eol(eol)

        for (i = 1; i < ARGC; i++) {
          print encode(url, ARGV[i])
        }
      }
    ' "$@"
  } | (
    set -- "$1"
    while IFS= read -r line; do
      set -- "$@" "$line"
    done
    printf -- "$@"
  )
}

SHURL_REMOVENULLKEY='' SHURL_DELIMITER='\n'
SHURL_SPACE='' SHURL_EOL='' SHURL_NONEWLINE=''
mode='build'
while [ $# -gt 0 ]; do
  case $1 in
    -SN | -NS) SHURL_SPACE='+' SHURL_EOL='\r\n' ;;
    -S) SHURL_SPACE='+' ;;
    -N) SHURL_EOL='\r\n' ;;
    -n) SHURL_NONEWLINE=1 ;;
    -r) SHURL_REMOVENULLKEY=1 ;;
    -p | --printf) mode='printf' ;;
    -j | --join) SHURL_DELIMITER=${2:-} && shift ;;
    -h | --help) usage && exit 0 ;;
    --) shift && break ;;
    -*) echo "Unknown option $1" >&2 && exit 1 ;;
    *) break ;;
  esac
  shift
done

sanitize() {
  replace_all sanitize "$2" '%' '%%'
  sanitize=$(printf "$sanitize"_) && sanitize=${sanitize%_}
  replace_all sanitize "$sanitize" '%' '%%'
  replace_all "$1" "$sanitize" "\\" "\\\\"
}
[ "$SHURL_DELIMITER" = '\n' ] || sanitize SHURL_DELIMITER "$SHURL_DELIMITER"

"do_url${mode}" "$@"
